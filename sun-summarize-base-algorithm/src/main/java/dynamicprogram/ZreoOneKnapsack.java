package dynamicprogram;

/**
 * @description: 0-1背包问题
 * @author: xy.sun06
 * @create: 2024-08-19 10:20
 * @Copyright (c) 2024, © 神州租车（北京）科技有限公司
 */
public class ZreoOneKnapsack {
	/**
	 * 给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。
	 * 其中第 i 个物品的重量为 wt[i]，价值为 val[i]。
	 * 现在让你用这个背包装物品，每个物品只能用一次，在不超过被包容量的前提下，最多能装的价值是多少？
	 *
	 * <p>========================================穷举框架=============================================================</p>
	 * for 状态1 in 状态1的所有取值：
	 * for 状态2 in 状态2的所有取值：
	 * for ...
	 * dp[状态1][状态2][...] = 择优(选择1，选择2...)
	 *
	 * <p>=========================================伪代码=============================================================</p>
	 * int[][] dp[N+1][W+1]
	 * dp[0][..] = 0
	 * dp[..][0] = 0
	 * <p>
	 * for i in [1..N]:
	 * for w in [1..W]:
	 * dp[i][w] = max(
	 * 把物品 i 装进背包,
	 * 不把物品 i 装进背包
	 * )
	 * return dp[N][W]
	 *
	 * <p>==========================================状态转移方程========================================================</p>
	 * 1、dp 数组的定义：
	 * dp[i][w] 表示：对于前 i 个物品（从 1 开始计数），当前背包的容量为 w 时，这种情况下可以装下的最大价值是 dp[i][w]。
	 * <p>
	 * 2、推导
	 * （1）如果你没有把这第 i 个物品装入背包，那么很显然，最大价值 dp[i][w] 应该等于 dp[i-1][w]，继承之前的结果。
	 * （2）如果你把这第 i 个物品装入了背包，那么 dp[i][w] 应该等于 val[i-1] + dp[i-1][w - wt[i-1]]。
	 * <p>
	 * 首先，由于数组索引从 0 开始，而我们定义中的 i 是从 1 开始计数的，所以 val[i-1] 和 wt[i-1] 表示第 i 个物品的价值和重量。
	 * 你如果选择将第 i 个物品装进背包，那么第 i 个物品的价值 val[i-1] 肯定就到手了，
	 * 接下来你就要在剩余容量 w - wt[i-1] 的限制下，在前 i - 1 个物品中挑选，求最大价值，即 dp[i-1][w - wt[i-1]]。
	 * <p>
	 * for i in [1..N]:
	 * for w in [1..W]:
	 * dp[i][w] = max(
	 * dp[i-1][w],
	 * dp[i-1][w - wt[i-1]] + val[i-1]
	 * )
	 * return dp[N][W]
	 *
	 * @param W   可装载重量
	 * @param N   物品
	 * @param wt  i 个物品的重量
	 * @param val i 个物品的价值
	 * @return 最大价值
	 */
	private int knapsack(int W, int N, int[] wt, int[] val) {
		int[][] dp = new int[N + 1][W + 1];

		// 自底向上
		for (int i = 1; i <= N; i++) {
			for (int w = 1; w <= W; w++) {
				if (w - wt[i - 1] < 0) {
					// 这种情况下只能选择不装入背包
					dp[i][w] = dp[i - 1][w];
				} else {
					// 装入或者不装入背包，择优
					dp[i][w] = Math.max(
						// 把物品 i 装进背包
						// 在剩余容量 w - wt[i-1] 的限制下，在前 i - 1 个物品中挑选，求最大价值
						dp[i - 1][w - wt[i - 1]] + val[i - 1],
						// 把物品 i 没装进背包
						// dp[i][w] 等于 dp[i-1][w]，继承之前的结果。
						dp[i - 1][w]
					);
				}
			}
		}
		return dp[N][W];
	}
}
