package monotonous;

import java.util.Stack;

/**
 * @description: 单调栈-栈中最小值
 * @author: xy.sun06
 * @create: 2024-08-21 11:56
 * @Copyright (c) 2024, © 神州租车（北京）科技有限公司
 */
public class MonotonousStack {
	// 记录栈中的所有元素
	Stack<Integer> stk = new Stack<>();
	// 阶段性记录栈中的最小元素
	Stack<Integer> minStk = new Stack<>();

	public MonotonousStack() {
	}

	/**
	 * eg: 栈中的最小值
	 * <p>
	 * 入栈 2 此时栈中为空，单调栈直接入栈2，此时单调栈的值为：2
	 * 入栈 1 如果输入值1小于当前单调栈中的栈首值2，则直接入单调栈，此时单调栈的值为 1->2
	 * 入栈 5 如果输入值5大于当前单调栈中的栈首值1，获取此时单调栈中的栈首值1，再次加入单调栈，此时单调栈的值为 1->1->2
	 * 入栈 4 如果输入值4大于当前单调栈中的栈首值1，获取此时单调栈中的栈首值1，再次加入单调栈，此时单调栈的值为 1->1->1->2
	 * 入栈 0 如果输入值0小于当前单调栈中的栈首值1，则直接入单调栈，此时单调栈的值为 0->1->1->1->2
	 * <p>
	 * 开始出栈（先进后出）
	 * 此时栈中的值：   0—>4->5->1->2
	 * 此时单调栈中的值：0->1->1->1->2
	 * <p>
	 * 0 出栈  单调栈中的栈顶出栈  此时单调栈的值为 1->1->1->2
	 * 4 出栈  单调栈中的栈顶出栈  此时单调栈的值为 1->1->2
	 * 5 出栈  单调栈中的栈顶出栈  此时单调栈的值为 1->2
	 * 1 出栈  单调栈中的栈顶出栈  此时单调栈的值为 2
	 * <p>
	 * ========总结========
	 * 入栈：当前值小于当前单调栈栈顶的值，直接入单调栈，如果当前值大于当前单调栈的栈顶值，则获取栈顶值，再次入栈
	 * 出栈：1对1，跟随出栈
	 * <p>
	 * ========思考如何获取栈的最大值？========
	 * <p>
	 * 入栈1 此时栈中为空，单调栈直接入栈1，此时单调栈的值为：1
	 * 入栈6 此时栈首的值为1，入栈值6大于栈首1，直接入栈， 此时单调栈的值为：6->1
	 * 入栈2 此时栈首的值为6，入栈值2小于栈首6，获取栈首值6，再入栈， 此时单调栈的值为：6->6->1
	 * 入栈3 此时栈首的值为6，入栈值3小于栈首6，获取栈首值6，再入栈， 此时单调栈的值为：6->6->6->1
	 * <p>
	 * 出栈3 单调栈出栈6 此时单调栈6->6->1
	 * 出栈2 单调栈出栈6 此时单调栈6->1
	 * 出栈6 单调栈出栈6 此时单调栈1
	 *
	 * @param val 入栈的值
	 */
	public void push(int val) {
		stk.push(val);
		// 维护 minStk 栈顶为全栈最小元素
		if (minStk.isEmpty() || val <= minStk.peek()) {
			// 新插入的这个元素就是全栈最小的
			minStk.push(val);
		} else {
			// 插入的这个元素比较大
			minStk.push(minStk.peek());
		}
	}

	public void pop() {
		stk.pop();
		minStk.pop();
	}

	public int top() {
		return stk.peek();
	}

	public int getMin() {
		// minStk 栈顶为全栈最小元素
		return minStk.peek();
	}
}
