zk单个节点都存储了哪些信息
-------
ZooKeeper中的每个节点都有一个唯一的路径标识，‌这个路径就是节点的键（‌key）‌，‌而节点的内容则是该节点的值（‌value）‌。‌具体来说，‌ZooKeeper通过以下方式存储每个节点的信息：‌
- 节点路径作为键（‌key）‌：‌每个节点的路径在ZooKeeper中是唯一的，‌用于标识节点的位置。‌这些路径类似于文件系统中的文件路径，‌用于快速定位和访问特定的节点数据。‌
- 节点数据内容作为值（‌value）‌：‌每个节点都有一个与之关联的数据值，‌这个值可以是任何数据，‌包括字符串、‌字节数组等，‌用于存储实际的数据信息。
  - ‌ZooKeeper使用DataNode类来存储节点数据，‌确保数据的正确性和一致性。‌
  - 此外，‌ZooKeeper还支持对节点数据进行版本控制，‌通过版本号的概念来确保在并发更新时数据的正确性和一致性。‌如果存在多个客户端同时尝试修改同一节点数据，‌ZooKeeper会根据版本号来确定哪个更新是最终的，‌从而避免数据冲突。‌
  - ZooKeeper还提供了对节点数据的监视（‌watch）‌功能，‌允许客户端对特定节点的变化进行监视，‌当节点数据发生变化时，‌ZooKeeper会通知那些对此节点感兴趣并设置了监视的客户端。‌这种机制有助于实现分布式系统中的高效数据同步和事件驱动的处理。‌
>> 总的来说，‌ZooKeeper单个节点存储的信息主要是节点的路径和与之关联的数据内容，‌通过这些信息，‌ZooKeeper实现了分布式系统中数据的集中管理和高效同步
zk查看一个节点的命令是啥
--------
zk集群选举时集群是否可用，当前节点数为偶数时，是否可以完成选举过程
------
* Zookeeper集群的数量为奇数个
   （注意：这里并不是说偶数个就不行，而是：比如：5台和6台集群的容灾能力是一样的，所以我们可以少用一台达到相同的目的）
* 在ZooKeeper中，有三种角色：Leader，Follower，Observer

    - 一个ZooKeeper集群同一时刻只会有一个Leader，其他都是Follower或Observer。
    - Zookeeper集群中的任何一台机器都可以响应客户端的读操作，且全量数据都存在于内存中，因此Zookeeper更适合以读操作为主的应用场景。
    >注意，当不是leader的服务器收到客户端事务操作，他会将其转发到Leader，让Leader进行处理。
    - ZooKeeper集群的所有机器通过一个Leader选举过程来选定一台被称为『Leader』的机器，Leader服务器为客户端提供读和写服务。
    - Follower和Observer都能提供读服务，不能提供写服务。

 两者唯一的区别在于，Observer机器不参与Leader选举过程，也不参与写操作的『过半写成功』策略，因此Observer可以在不影响写性能的情况下提升集群的读性能。

如何认定zk集群彻底挂掉
-----
判断ZooKeeper集群是否彻底挂掉的关键在于观察集群是否无法进行正常的服务，‌特别是无法进行创建和释放锁的操作。‌

ZooKeeper集群的挂掉可能表现为无法进行正常的服务，‌特别是在创建和释放锁的过程中。
‌由于ZooKeeper的锁功能是通过动态创建、‌销毁瞬时节点来实现的，‌而这些操作只能通过Leader服务器来执行，‌并将数据同步到所有的Follower机器上。
‌如果集群无法进行这些操作，‌那么可以认为集群已经挂掉。
‌此外，‌如果集群中的节点无法进行有效的投票选举，‌例如在集群扩容或缩减时，‌如果新加入的节点无法获得投票或现有节点无法正确更新其投票状态，‌这也可能是集群挂掉的一个表现。‌

具体来说，‌如果ZooKeeper集群彻底挂掉，‌可能会出现以下情况：‌

* 无法进行创建和释放锁的操作：
  * ‌这是因为在ZooKeeper中，‌创建和删除节点只能通过Leader服务器来执行，‌然后将数据同步到所有的Follower机器上。 ‌如果集群无法进行这些操作，‌那么可以认为集群已经挂掉。‌
* 节点投票选举异常：
  * ‌在集群扩容或缩减时，‌如果新加入的节点无法获得投票或现有节点无法正确更新其投票状态，‌这也可能是集群挂掉的一个表现。‌
> 综上所述，‌如果ZooKeeper集群无法进行正常的服务，‌特别是在创建和释放锁的过程中出现问题，‌以及在节点投票选举过程中出现异常，‌这些都是判断ZooKeeper集群是否彻底挂掉的重要依据

创建对象的方式有哪些
--------
* new关键字
* Class.newInstance
* Constructor.newInstance
* Clone方法
* 反序列化

dubble基于什么（传输层）协议实现的
-------
利用Netty，TCP传输，单一、异步、长连接，适合数据量小、高并发和服务提供者远远少于消费者的场景。Dubbo通过TCP长连接的方式进行通信，服务粒度是方法级的。

[dubbo的协议选择](https://juejin.cn/post/7159461050994294820)
------
- gPRC 协议
  Dubbo 自 2.7.5 版本开始支持 gRPC 协议，对于计划使用 HTTP/2 通信，或者想利用 gRPC 带来的 Stream、反压、Reactive 编程等能力的开发者来说， 都可以考虑启用 gRPC 协议。

- dubbo 协议
  默认就是走 dubbo 协议，单一长连接，进行的是 NIO 异步通信，基于 hessian 作为序列化协议。使用的场景是：传输数据量小（每次请求在 100kb 以内），但是并发量很高，以及服务消费者机器数远大于服务提供者机器数的情况。
  为了要支持高并发场景，一般是服务提供者就几台机器，但是服务消费者有上百台，可能每天调用量达到上亿次！此时用长连接是最合适的，就是跟每个服务消费者维持一个长连接就可以，可能总共就 100 个连接。然后后面直接基于长连接 NIO 异步通信，可以支撑高并发请求。
  长连接，通俗点说，就是建立连接过后可以持续发送请求，无须再建立连接。

[dubbo与feign对比](https://www.cnblogs.com/ying-z/p/14781757.html)
-------
* Feign与Dubbo的对比
  * Feign与Dubbo功能上有很多类似的地方，因为都是专注于远程调用这个动作。比如注册中心解耦、负载均衡、失败重试熔断、链路监控等。
  * Dubbo除了注册中心需要进行整合，其它功能都自己实现了，而Feign大部分功能都是依赖全家桶的组件来实现的。Dubbo小而专一，专注于远程调用。而Spring全家桶而言，远程调用只是一个重要的功能而已。

* 协议支持方面：
  * Feign更加优雅简单。Feign是通过REST API实现的远程调用，基于Http传输协议，服务提供者需要对外暴露Http接口供消费者调用，服务粒度是http接口级的。通过短连接的方式进行通信，不适合高并发的访问。Feign追求的是简洁，少侵入（因为就服务端而言，在SpringCloud环境下，不需要做任何额外的操作，而Dubbo的服务端需要配置开放的Dubbo接口)。
  * Dubbo方式更灵活。Dubbo是通过RPC调用实现的远程调用，支持多传输协议(Dubbo、Rmi、http、redis等等)，可以根据业务场景选择最佳的方式，非常灵活。默认的Dubbo协议：利用Netty，TCP传输，单一、异步、长连接，适合数据量小、高并发和服务提供者远远少于消费者的场景。Dubbo通过TCP长连接的方式进行通信，服务粒度是方法级的。
  从协议层选择看，Dubbo是配置化的，更加灵活。Dubbo协议更适合小数据高并发场景。

* 通信性能方面：
  * 从通信的性能上来分析，SpringCloud的通信采用Openfeign（feign）组件。
  Feign基于Http传输协议，底层实现是rest。从OSI 7层模型上来看rest属于应用层。
  在高并发场景下性能不够理想，成为性能瓶颈（虽然他是基于Ribbon以及带有熔断机制可以防止雪崩），需要改造。具体需要改造的内容需要时再研究。
  * Dubbo框架的通信协议采用RPC协议，属于传输层协议，性能上自然比rest高。提升了交互的性能，保持了长连接，高性能。
  Dubbo性能更好，比如支持异步调用、Netty性能更好。Dubbo主要是配置而无需改造。

[服务治理的选择](https://cloud.baidu.com/article/2695862)
------
在微服务架构中，服务注册与发现是实现服务间通信的关键环节。本文将对比分析ZooKeeper、Eureka、Consul和Nacos这四种常见的微服务注册中心，从功能、性能、易用性和可扩展性等方面进行深入探讨。
* 一、功能
  * ZooKeeper：作为分布式协调服务，ZooKeeper提供了基于ZNode（节点）的数据存储和分布式同步功能。它主要用于管理配置信息、命名服务和分布式同步等。
  * Eureka：Eureka是一个基于Java的开源服务注册与发现组件，提供了灵活的配置和易于使用的API接口。它实现了服务间的快速发现和故障转移功能。
  * Consul：Consul是HashiCorp公司开发的开源工具，用于构建分布式系统的服务发现、配置和服务管理。它支持跨平台和多语言，提供了高可用性和可扩展性。
  * Nacos：Nacos是一个开源的、易于使用的、功能丰富的平台，用于构建云原生应用。它支持动态服务发现、配置管理和服务管理等功能。
* 二、性能
  * Eureka：Eureka的性能表现相对稳定，但在高并发场景下可能存在性能瓶颈。
  * Consul：Consul具有较好的性能表现，特别是在高并发场景下表现出色。
  * Nacos：Nacos的性能表现优秀，支持大规模的微服务集群部署，具有高可用性和可扩展性。
* 三、易用性
  * ZooKeeper：由于ZooKeeper的使用需要一定的门槛，因此对于初学者来说可能有一定的学习曲线。
  * Eureka：Eureka的使用相对简单，提供了友好的API和易于理解的文档。
  * Consul：Consul的使用也相对简单，提供了丰富的功能和易于使用的命令行工具。
  * Nacos：Nacos的易用性较高，提供了可视化的管理界面和简单的配置管理功能。
* 四、可扩展性
  * ZooKeeper：ZooKeeper具有良好的可扩展性，可以通过增加服务器节点来提高整体性能和可用性。
  * Eureka：Eureka也具备良好的可扩展性，通过增加Eureka Server实例可以支持更多的服务注册与发现需求。
  * Consul：Consul同样具有出色的可扩展性，支持跨数据中心部署和多租户模式。
  * Nacos：Nacos的可扩展性较高，支持动态扩容和多租户模式。

> 总结：
在选择微服务注册中心时，需要根据实际需求进行综合考虑。ZooKeeper适用于需要高度自定义和强一致性的场景；Eureka适用于需要快速迭代和易于维护的中小型微服务项目；Consul适用于需要高性能和可扩展的大型微服务项目；而Nacos则适用于需要一站式解决方案的云原生应用开发。
spring的bean初始化过程
-----

[bean的循环依赖如何解决]()
----
[见滴滴第一轮面试标题一](/didi/first/Question.md#1bean的三级缓存)

何时Spring的事物会失效，如何处理
-------
[见滴滴第一轮面试标题八](/didi/first/Question.md#8spring什么时候事物会失效一个service里a方法调用b方法如何失效)

spring获取一个类的代理类有几种方式
-----
在Spring框架中，你可以通过多种方式获取类的代理类。以下是一些常见的方法：
* 使用ApplicationContext获取：
  - `MyClass myClass = applicationContext.getBean(MyClass.class);`
  - 如果你的类已经被Spring容器管理，你可以通过ApplicationContext获取到它的代理类。
* 使用@Autowired或@Resource注解：
  * 你可以在需要的地方使用@Autowired或@Resource注解，让Spring自动注入该类的代理对象。
* 使用AopContext获取：
  * 如果你的类是一个被AOP（面向切面编程）增强的bean，你可以使用AopContext.currentProxy()方法获取当前代理对象。但是要注意，这需要设置expose-proxy="true"。
  * `MyClass myClass = (MyClass) AopContext.currentProxy();`

jdk动态代理与cglib动态代理的区别,jdk动态代理为什么效率高
----
- JDK动态代理‌
  - JDK动态代理是基于Java的反射机制实现的，它只能为接口创建代理实例。这种代理方式是通过实现InvocationHandler接口来定义横切逻辑，并通过反射机制调用目标类的代码，将横切逻辑和业务逻辑结合在一起。JDK动态代理是面向接口的代理模式，如果被代理目标没有接口，那么Spring也无法通过反射机制生产被代理接口的新的匿名实现类，重写其中的增强方法。
- CGLIB动态代理‌
  - CGLIB是一个高性能的Code生成类库，它采用底层的字节码技术（全称是Code Generation Library），可以为一个类创建一个子类。在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑。CGLIB动态代理利用ASM框架对代理对象类生成的class文件加载进来，通过修改其字节码生成子类来进行代理。

> JDK动态代理的效率较高，主要是因为它的实现基于接口，避免了直接操作字节码的复杂性。而CGLIB虽然功能强大，但因为它需要生成子类并修改字节码，所以在某些情况下可能会比JDK动态代理慢。此外，JDK动态代理不需要任何外部依赖，这也是它在效率上占优势的一个原因。







