jvm分区
-----
(Java虚拟机）的内存区域主要划分为几个关键部分，这些区域共同协作以确保Java程序的正确执行和内存管理。以下是JVM内存区域的主要划分及其作用：

‌主要内存区域及其作用‌
* ‌堆（Heap）‌：用于动态分配内存，存储对象实例。这是JVM管理的最大一块内存区域，几乎所有对象实例都存储在这里。堆被进一步细分为年轻代和老年代，其中年轻代包含‌Eden区和两个Survivor区，而老年代则存储生命周期较长的对象。
* ‌栈（Stack）‌：每个线程在JVM中都有一个私有的栈，用于存储局部变量、操作数栈、动态链接、方法出口信息等。栈内存的申请和释放都是自动的，无需显式管理。
* 方法区（Method Area）‌：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。在Java 8及以后的版本中，这个区域被称为元空间（Metaspace）。
* ‌程序计数器（Program Counter Register）‌：这是JVM中最小的一块内存区域，用于存储当前线程执行的字节码地址。每个线程都有一个独立的程序计数器。
* ‌本地方法栈（Native Method Stack）‌：与虚拟机栈类似，但用于支持本地方法调用。

‌垃圾回收机制‌
* ‌堆区域的垃圾回收‌：JVM通过垃圾回收机制自动管理堆内存。垃圾回收器会识别并回收不再使用的对象，以防止内存泄漏和提高系统性能。
* ‌垃圾回收算法‌：常见的垃圾回收算法包括标记-清除、复制、标记-整理和分代收集等。这些算法根据对象的存活时间和大小，在年轻代和老年代采用不同的策略进行内存回收。
> 通过这些区域的划分和垃圾回收机制，JVM能够有效地管理内存，确保Java程序的稳定运行。每个区域都有其特定的职责和生命周期管理策略，共同协作以支持Java程序的执行。‌

[新生代垃圾回收过程](https://blog.csdn.net/m0_58221836/article/details/138186592)
-----
复制算法的基本思想是将堆内存划分为两个大小相等的区域，通常称为"From"空间和"To"空间。在初始状态下，所有的存活对象都位于From空间中。

执行垃圾回收时，复制算法会遍历From空间中的存活对象，并将它们复制到To空间中。复制过程中，对象的布局会保持原样，但对象之间的相对顺序可能会改变。

复制完成后，From空间中的存活对象已经被复制到To空间中，而From空间中未被复制的对象则被认为是不可达的垃圾对象。此时，整个From空间可以被视为一片连续的可用内存，无需进行复杂的内存碎片整理。

复制算法的优点包括：

* 消除内存碎片：由于复制算法在回收过程中将存活对象复制到新的内存空间，它可以有效地消除内存碎片问题。
* 简单高效：复制算法的实现相对简单且高效，适用于管理小到中等大小的堆内存
* 标记-复制算法，在这个基础之上对其进行了优化，IBM曾有过一项针对新生代的研究，结论是绝大多数情况下，新生代区域里的对象有98%都熬不过第一次回收。

所以不需要按照 1 : 1 的比例来实现复制算法，而是可以按照 8 : 1 : 1 的比例来分配内存空间，也就是一个80%的Eden空间和两个10%的Survivor空间。

每次分配内存，只使用Eden和其中一块Survivor空间，发生GC回收时，把Eden和其中一块Survivor空间中存活的对象，复制到另一块空闲的Survivor空间，然后直接把Eden和使用过的那块Survivor空间清理掉。

属性m和属性n分别存储在jvm哪里
-----
````
class A {
// 存放在堆中
private int m;

public void hello(){
   // 存放在栈中
   int n;
  }
}
````

[synchronized的实现原理]()
-----
[详情见](./sun-summarize-base-java/src/main/java/synchronizeds/README.md)
* 什么时候会用到synchronized锁（A.class）
* 与ReentrantLock对比

[AQS原理](https://javaguide.cn/java/concurrent/aqs.html)
------

[数据库幻读是什么场景](https://www.cnblogs.com/a-phper/p/10313933.html)
----
[隔离级别](https://www.cnblogs.com/vipstone/p/16422573.html)

[mysql如何解决的幻读（间隙锁）](https://note.youdao.com/s/Ve6g3HL)
-----

死锁产生的原因
-----

这种情况事物为什么会失效
------
````
class A{

   @Transactional
   public B(){
       this.c()
   }

   @Transactional
   public C(){
   }
}
````
同一个事物的数据库链接spring如何管理的
------

B树和B+树的区别
------






