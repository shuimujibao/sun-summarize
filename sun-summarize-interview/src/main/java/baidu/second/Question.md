jvm分区
-----
(Java虚拟机）的内存区域主要划分为几个关键部分，这些区域共同协作以确保Java程序的正确执行和内存管理。以下是JVM内存区域的主要划分及其作用：

‌主要内存区域及其作用‌
* ‌堆（Heap）‌：用于动态分配内存，存储对象实例。这是JVM管理的最大一块内存区域，几乎所有对象实例都存储在这里。堆被进一步细分为年轻代和老年代，其中年轻代包含‌Eden区和两个Survivor区，而老年代则存储生命周期较长的对象。
* ‌栈（Stack）‌：每个线程在JVM中都有一个私有的栈，用于存储局部变量、操作数栈、动态链接、方法出口信息等。栈内存的申请和释放都是自动的，无需显式管理。
* 方法区（Method Area）‌：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。在Java 8及以后的版本中，这个区域被称为元空间（Metaspace）。
* ‌程序计数器（Program Counter Register）‌：这是JVM中最小的一块内存区域，用于存储当前线程执行的字节码地址。每个线程都有一个独立的程序计数器。
* ‌本地方法栈（Native Method Stack）‌：与虚拟机栈类似，但用于支持本地方法调用。

‌垃圾回收机制‌
* ‌堆区域的垃圾回收‌：JVM通过垃圾回收机制自动管理堆内存。垃圾回收器会识别并回收不再使用的对象，以防止内存泄漏和提高系统性能。
* ‌垃圾回收算法‌：常见的垃圾回收算法包括标记-清除、复制、标记-整理和分代收集等。这些算法根据对象的存活时间和大小，在年轻代和老年代采用不同的策略进行内存回收。
> 通过这些区域的划分和垃圾回收机制，JVM能够有效地管理内存，确保Java程序的稳定运行。每个区域都有其特定的职责和生命周期管理策略，共同协作以支持Java程序的执行。‌

[新生代垃圾回收过程](https://blog.csdn.net/m0_58221836/article/details/138186592)
-----
复制算法的基本思想是将堆内存划分为两个大小相等的区域，通常称为"From"空间和"To"空间。在初始状态下，所有的存活对象都位于From空间中。

执行垃圾回收时，复制算法会遍历From空间中的存活对象，并将它们复制到To空间中。复制过程中，对象的布局会保持原样，但对象之间的相对顺序可能会改变。

复制完成后，From空间中的存活对象已经被复制到To空间中，而From空间中未被复制的对象则被认为是不可达的垃圾对象。此时，整个From空间可以被视为一片连续的可用内存，无需进行复杂的内存碎片整理。

复制算法的优点包括：

* 消除内存碎片：由于复制算法在回收过程中将存活对象复制到新的内存空间，它可以有效地消除内存碎片问题。
* 简单高效：复制算法的实现相对简单且高效，适用于管理小到中等大小的堆内存
* 标记-复制算法，在这个基础之上对其进行了优化，IBM曾有过一项针对新生代的研究，结论是绝大多数情况下，新生代区域里的对象有98%都熬不过第一次回收。

所以不需要按照 1 : 1 的比例来实现复制算法，而是可以按照 8 : 1 : 1 的比例来分配内存空间，也就是一个80%的Eden空间和两个10%的Survivor空间。

每次分配内存，只使用Eden和其中一块Survivor空间，发生GC回收时，把Eden和其中一块Survivor空间中存活的对象，复制到另一块空闲的Survivor空间，然后直接把Eden和使用过的那块Survivor空间清理掉。

属性m和属性n分别存储在jvm哪里
-----
````
class A {
// 存放在堆中
private int m;

public void hello(){
   // 存放在栈中
   int n;
  }
}
````

[synchronized的实现原理]()
-----
[详情见](./sun-summarize-base-java/src/main/java/synchronizeds/README.md)
* 什么时候会用到synchronized锁（A.class）
* 与ReentrantLock对比

[AQS原理](https://javaguide.cn/java/concurrent/aqs.html)
------

[数据库幻读是什么场景](https://www.cnblogs.com/a-phper/p/10313933.html)
----
MySQL 中有 4 种事务隔离级别：
* 读未提交（存在脏读/不可重复读/幻读问题）、
* 读已提交（存在不可重复读/幻读问题）、
* 可重复读（存在幻读问题）和序列化，
* 其中可重复读是 MySQL 默认的事务隔离级别。
  * 脏读是读到了其他事务未提交的数据，
  * 不可重复读是读到了其他事务修改的数据，
  * 而幻读则是读取到了其他事务新增或删除的“幻像”行数据。
    [隔离级别](https://www.cnblogs.com/vipstone/p/16422573.html)

[mysql如何解决的幻读（间隙锁）](https://note.youdao.com/s/Ve6g3HL)
-----

[死锁产生的原因](https://xiaolincoding.com/os/4_process/deadlock.html#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%91%E7%94%9F)
-----
> 简单来说，死锁问题的产生是由两个或者以上线程并行执行的时候，争夺资源而互相等待造成的。

死锁只有同时满足
* 互斥
  * 互斥条件是指多个线程不能同时使用同一个资源。
* 持有并等待
  * 持有并等待条件是指，当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C 持有了，所以线程 A 就会处于等待状态，但是线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1。
* 不可剥夺
  * 不可剥夺条件是指，当线程已经持有了资源 ，在自己使用完之前不能被其他线程获取，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。
* 环路等待
  * 环路等待条件指的是，在死锁发生的时候，两个线程获取资源的顺序构成了环形链。
  * 比如，线程 A 已经持有资源 2，而想请求资源 1， 线程 B 已经获取了资源 1，而想请求资源 2，这就形成资源请求等待的环形图。

这四个条件的时候才会发生。

> 所以要避免死锁问题，就是要破坏其中一个条件即可，最常用的方法就是使用资源有序分配法来破坏环路等待条件。

这种情况事物为什么会失效
------
````
class A{

   @Transactional
   public B(){
       this.c()
   }

   @Transactional
   public C(){
   }
}
````
同一个事物的数据库链接spring如何管理的
------

[B树和B+树的区别](https://developer.aliyun.com/article/1519395)
------

B树和B+树是常见的数据库索引结构，都具有相较于二叉树层级较少，查找效率高的特点，它们之间有以下几个主要区别：

* 1.节点存储数据的方式不同
  * B树的叶子结点和非叶子节点都会存储数据，指针和数据共同保存在同一节点中
  * B+树数据均保存在叶子节点，非叶子节点只存储索引信息。
* 2.查找数据过程不同
  * B树需要在各个节点上进行查找，查找数据的效率不稳定
  * B+树需要在叶子节点上查找，非叶子节点只用于索引定位，每次查找都会从父节点到叶子节点结束
* 3.空间利用率不同
  * B树每个节点都存储数据，空间利用率相对较低
  * B+树只有叶子节点存储数据，非叶子节点只存储索引信息，空间利用率更高
* 4.结构稳定性不同
  * B树插入和删除数据需要频繁变更树的结构，结构不稳定
  * B+树插入和删除数据操作均放在叶子节点，维护了树结构的稳定性
* 5.范围查找性能不同
  * B树需要在各个节点上逐个查找,范围查找效率较低。
  * B+树所有数据记录都存储在叶子节点上,且叶子节点同时还维护了一条双向链表，提高范围查询的效率
* 6.适用场景不同
  * B树更适合于数据库的索引结构,处理大量点查询。
  * B+树更适合文件系统等场景,处理大量范围查询和排序操作。
总之,B+树相比B树有更好的空间利用率和查询性能,更适合用作大型数据库的索引结构。




