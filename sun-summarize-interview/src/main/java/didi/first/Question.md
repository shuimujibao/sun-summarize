1.bean的三级缓存
------

* singletonObjects：用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用
* earlySingletonObjects：提前曝光的单例对象的cache，存放原始的 bean 对象（尚未填充属性），用于解决循环依赖
* singletonFactories：单例对象工厂的cache，存放 bean 工厂对象，用于解决循环依赖

> 先从一级缓存singletonObjects中去获取。（如果获取到就直接return）如果获取不到或者对象正在创建中（isSingletonCurrentlyInCreation()），
> 那就再从二级缓存earlySingletonObjects中获取。（如果获取到就直接return）如果还是获取不到，且允许singletonFactories（allowEarlyReference=true）
> 通过getObject()获取。就从三级缓存singletonFactory.getObject()获取。
> 如果获取到了就从singletonFactories中移除，并且放进earlySingletonObjects。其实也就是从三级缓存移动（是剪切、不是复制哦~）到了二级缓存）
> 加入singletonFactories三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决


 依旧以上面A、B类使用属性field注入循环依赖的例子为例，对整个流程做文字步骤总结如下：

 1.使用context.getBean(A.class)，旨在获取容器内的单例A(若A不存在，就会走A这个Bean的创建流程)，显然初次获取A是不存在的，因此走A的创建之路~

 2.实例化A（注意此处仅仅是实例化），并将它放进缓存（此时A已经实例化完成，已经可以被引用了）

 3.初始化A：@Autowired依赖注入B（此时需要去容器内获取B）

 4.为了完成依赖注入B，会通过getBean(B)去容器内找B。但此时B在容器内不存在，就走向B的创建之路~

 5.实例化B，并将其放入缓存。（此时B也能够被引用了）

 6.初始化B，@Autowired依赖注入A（此时需要去容器内获取A）

 7.此处重要：初始化B时会调用getBean(A)去容器内找到A,上面我们已经说过了此时候因为A已经实例化完成了并且放进了缓存里，所以这个时候去看缓存里是已经存在A的引用了的，所以getBean(A)能够正常返回

 8.B初始化成功（此时已经注入A成功了，已成功持有A的引用了），return（注意此处return相当于是返回最上面的getBean(B)这句代码，回到了初始化A的流程中~）。

 9.因为B实例已经成功返回了，因此最终A也初始化成功

 10.到此，B持有的已经是初始化完成的A，A持有的也是初始化完成的B，完美~


> getSingleton()从缓存里获取单例对象步骤分析可知，Spring解决循环依赖的诀窍：就在于singletonFactories这个三级缓存。这个Cache里面都是ObjectFactory，它是解决问题的关键

2.跳表如何实现 [解读](https://juejin.cn/post/6893072817206591496)
------
>跳表（skip list）对标的是平衡树（AVL Tree）和 二分查找，是一种 插入/删除/搜索 都是O(logn) 的数据结构。1989 年出现。

~~跳跃列表是一种数据结构。它允许快速查询一个有序连续元素的数据链表,而其快速查询是通过维护一个多层次的链表，且每一层链表中的元素是前一层链表元素的子集。
一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。
跳过的元素的方法可以是随机性选择或确定性选择，其中前者更为常见~~

- 跳跃表是有序集合的底层实现之一， 除此之外它在 Redis 中没有其他应用。
- Redis 的跳跃表实现由 zskiplist 和 zskiplistNode 两个结构组成， 其中 zskiplist 用于保存跳跃表信息（比如表头节点、表尾节点、长度）， 而 zskiplistNode 则用于表示跳跃表节点。
- 每个跳跃表节点的层高都是 1 至 32 之间的随机数。
- 在同一个跳跃表中， 多个节点可以包含相同的分值， 但每个节点的成员对象必须是唯一的。
- 跳跃表中的节点按照分值大小进行排序， 当分值相同时， 节点按照成员对象的大小进行排序。


3.重量级锁与ReentrantLock的区别，锁变化的过程 共享锁与独占锁的实现，轻量级锁为什么自璇
------
##### （1）独享锁 VS 共享锁

独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。
独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。

> 独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。
共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。

在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。
于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示：

##### （2）锁变化的过程
- 无锁
  - 无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。
- 偏向锁
  - 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。
  - 偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。

- 轻量级锁
  - 是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。
  - 如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。
  - 若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。
- 重量级锁
  - 升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。

> 综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。


##### （3）轻量级锁为什么自璇
* 首先，内核态与用户态的切换上不容易优化。但通过自旋锁，可以减少线程阻塞造成的线程切换（包括挂起线程和恢复线程）。
如果锁的粒度小，那么锁的持有时间比较短（尽管具体的持有时间无法得知，但可以认为，通常有一部分锁能满足上述性质）。
那么，对于竞争这些锁的而言，因为锁阻塞造成线程切换的时间与锁持有的时间相当，减少线程阻塞造成的线程切换，能得到较大的性能提升。

* 当前线程竞争锁失败时，打算阻塞自己,不直接阻塞自己，而是自旋（空等待，比如一个空的有限for循环）一会在自旋的同时重新竞争锁
如果自旋结束前获得了锁，那么锁获取成功；否则，自旋结束后阻塞自己

4.Eureka挂掉一个服务如何保证安全，如何摘掉挂掉的服务
------
> Eureka Server中有一个EvictionTask，用于检查服务是否失效。Eviction（失效服务剔除）用来定期（默认为每60秒）在Eureka Server检测失效的服务，
检测标准就是超过一定时间没有Renew的服务。默认失效时间为90秒，也就是如果有服务超过90秒没有向Eureka Server发起Renew请求的话，就会被当做失效服务剔除掉。
失效时间可以通过eureka.instance.leaseExpirationDurationInSeconds进行配置，定期扫描时间可以通过eureka.server.evictionIntervalTimerInMs进行配置。

服务剔除#evict方法中有很多限制，都是为了保证Eureka Server的可用性：
比如自我保护时期不能进行服务剔除操作、过期操作是分批进行、服务剔除是随机逐个剔除，剔除均匀分布在所有应用中，
防止在同一时间内同一服务集群中的服务全部过期被剔除，以致大量剔除发生时，在未进行自我保护前促使了程序的崩溃。

5.HashMap优化了哪些点 为什么初始值为2的倍数
------

* 奇数不行的解释很能被接受，在计算hash的时候，确定落在数组的位置的时候，计算方法是(n - 1) & hash ，奇数n-1为偶数，偶数2进制的结尾都是0，
经过&运算末尾都是0，会增加hash冲突

* 为啥要是2的幂，不能是2的倍数么，比如6，10？
  * HashMap结构是数组，每个数组里面的结构是node(链表或红黑树)，正常情况下，如果你想放数据到不同的位置，肯定会想到取余数确定放在那个数据里，
计算公式：hash % n，这个是十进制计算。在计算机中， (n - 1) & hash，当n为2次幂时，会满足一个公式：(n - 1) & hash = hash % n，计算更加高效。
  * 只有是2的幂数的数字经过n-1之后，二进制肯定是 ...11111111 这样的格式，这种格式计算的位置的时候，完全是由产生的hash值类决定，而不受n-1 影响。你可能会想，
受影响不是更好么，又计算了一下 ，hash冲突可能更低了，这里要考虑到扩容了，2的幂次方*2，在二进制中比如4和8，代表2的2次方和3次方，他们的2进制结构相似,
比如4和8 00000100 00001000 只是高位向前移了一位，这样扩容的时候，只需要判断高位hash,移动到之前位置的倍数就可以了，免去了重新计算位置的运算。

6.线程池的设计，如何选择最大线程数，工作队列，为什么用threadPoolExecutor(阿里巴巴开发手册)
------
> 选择最大线程数和工作队列时，‌需要考虑系统的资源情况、‌任务性质以及预期的并发量。‌

- 最大线程数的选择主要依赖于系统的资源限制和预期的并发量。‌
  - 如果应用程序运行在资源受限的环境中，‌如嵌入式系统或云服务器，‌需要限制最大线程数以避免过多线程占用资源。‌在这种情况下，‌最大线程数可以设置得相对较小。
  - ‌而对于需要处理大量并发请求的系统，‌可以适当增加最大线程数，‌以提高系统的并发处理能力。‌
- 工作队列的选择则取决于任务的性质和队列的行为特性。
  - ‌任务队列用于保存等待执行的任务，‌当所有核心线程都在工作时，‌新提交的任务会被添加到这个队列中等待执行。
  - ‌队列的类型（‌例如ArrayBlockingQueue、‌LinkedBlockingQueue或SynchronousQueue）‌会影响线程池的行为。‌
  - 例如，‌如果任务依赖于前一个任务的输出，‌应使用无界队列（‌如LinkedBlockingQueue）‌，‌因为它允许任务在队列中等待而不会丢失。‌如果任务不依赖于彼此，‌可以使用有界队列来避免资源过度消耗。‌

> 综上所述，‌选择最大线程数和工作队列时，‌需要综合考虑系统的资源情况、‌任务的性质以及预期的并发量，‌以确保线程池能够高效、‌稳定地运

7.在a ,b,c组合索引ab的查询过程和ac的查询过程最佳做前缀原则
------
联合索引的使用原则
从左到右依次匹配索引的列。
在这种情况下，索引A,B,C可以用于查询体条件中的列A，因为它是索引的最左边的列。然而，由于查询条件涉及的列 C 不是索引的下一个列，所以索引无法直接用于列 C 的查找。

8.Spring什么时候事物会失效，一个service里A方法调用B方法如何失效
------
Spring事务失效的原因可能有多种，以下是一些常见的原因以及解决方法：
- 方法不是public：
  - Spring的AOP代理只适用于public方法。如果你的方法不是public，Spring将无法创建代理来管理事务。解决方法是将方法声明为public。
- 注解使用不当：
  - 确保你在正确的类或方法上使用了@Transactional注解。例如，你不能在类级别的字段上使用该注解。解决方法是将注解正确地放在service层的public方法上。
- 事务方法被内部调用：
  - 如果你在同一个类中内部调用了一个被@Transactional注解的方法，事务将不会起作用，因为这等同于本地方调用。解决方法是确保你的事务方法被不同的类的方法或通过代理调用。
- 异常处理不当：
  - 默认情况下，Spring事务仅在运行时异常(RuntimeException)和错误(Error)发生时才回滚。如果你在事务方法中捕获了异常并未重新抛出，事务不会回滚。解决方法是在捕获异常后，合适的情况下重新抛出异常或者使用@Transactional注解的rollbackFor属性指定需要回滚的异常类型。
- 事务传播行为不当：
  - @Transactional注解的propagation属性可以控制事务的传播行为。如果设置不当，可能导致事务失效。解决方法是根据实际情况合理设置传播行为。
- 多线程环境问题：
  - 在多线程环境下，每个线程都有自己的事务，这些事务之间不会相互影响。解决方法是确保在正确的线程中使用事务。
- 数据库本身不支持事务：
  - 如果你使用的是不支持事务的数据库，比如MySQL的MyISAM存储引擎，Spring事务管理器将无法工作。解决方法是更换支持事务的数据库存储引擎。
- 配置问题：
  - 检查Spring事务管理器的配置是否正确，包括数据源、事务管理器的定义以及是否注入到了使用事务的Bean中。
- 未启用注解：
  - 确保你已经在Spring配置中启用了@Transactional注解。解决方法是在Spring配置中添加<tx:annotation-driven />标签或者相应的Java配置。
- 方法不是被Spring管理的Bean调用：
  - 如果你的方法不是由Spring管理的Bean调用，事务也不会起作用。解决方法是确保调用事务方法的是Spring管理的Bean。
- 类加载问题：
  - 如果你的类是通过类加载器动态加载的，Spring可能无法为这些类创建代理。解决方法是确保类加载时Spring容器已经加载了需要的Bean。
- 版本问题：
  - 确保你使用的Spring版本支持你正在使用的@Transactional注解的所有特性。

9.分布式锁的实现，选择那种实现 redLock 效率
------

10.如何通过反射拿到类中的私有属性
------

11.如何判断是同一个对象，同一个实例
------
