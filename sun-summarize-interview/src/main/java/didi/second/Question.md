nio为什么要堆外内存
-----
NIO使用堆外内存主要是为了避免在I/O操作过程中发生垃圾收集（GC）导致的内存地址变化，从而确保数据的一致性和操作的稳定性。

* 在Java的NIO（New I/O）中，堆外内存的使用主要是为了解决在I/O操作过程中可能遇到的内存管理问题。由于Java的垃圾收集器在运行时可能会移动对象在内存中的位置，进行碎片整理，这会导致内存地址的变化。如果在I/O操作进行中发生了GC，那么原本稳定的内存地址就会发生变化，进而导致I/O操作的数据混乱。为了避免这种情况，NIO采用了堆外内存的方式来进行I/O操作。堆外内存不受Java垃圾收集器的管理和控制，因此在进行I/O操作时，数据可以先被拷贝到堆外内存中，然后再进行I/O操作，这样就避免了在I/O操作过程中由于GC导致的内存地址变化问题。
* 此外，使用堆外内存还可以提高I/O操作的性能。通过FileChannel直接使用Native函数库分配堆外内存，并通过DirectByteBuffer对象作为这块内存的直接引用进行操作，可以避免在Java堆和Native堆之间频繁复制数据，从而在一些场景下能够显著提高I/O操作的性能‌1。

分布式锁为什么要用lua脚本，只用setnx不可以么
-----
保证原子性

cms什么时候降级为单线程回收器
-----

> CMS（Concurrent Mark Sweep）垃圾收集器是一种以获取最短回收停顿时间为目标的收集器，但并不保证系统的并发能力。
> 在某些情况下，JVM可能会将CMS作为全线收集器使用，降级为单线程收集器（ParNew收集器）进行垃圾回收。这种情况通常发生在老年代空间不足或者CMS收集过程中出现严重的并发问题时。

**降级为单线程的CMS收集器通常会在以下几种情况下触发：**

1. 并发模式失败：CMS收集器在尝试进行并发收集时，如果检测到当前运行的线程数量超过了JVM启动参数-XX:CMSInitiatingOccupancyFraction指定的值，就会触发一次并发失败，导致CMS无法并发执行，进而降级为单线程。
2. 老年代空间不足：当老年代空间不足以为新对象分配内存时，CMS收集器会被触发来进行垃圾收集。
3. 内存碎片化严重：内存碎片化过严时，可能导致并发采集过程中无法找到足够的连续空间来分配对象，这时候也会触发CMS的单线程执行。

**解决这类问题的方法通常包括：**

1. 增加老年代空间大小。
2. 通过JVM启动参数调整，如增加线程数-XX:ParallelGCThreads或减少CMS并发时的压力-XX:CMSInitiatingOccupancyFraction。
3. 优化应用程序的内存使用，减少内存分配频率和垃圾对象产生率。
4. 使用更高效的垃圾收集器，如G1收集器，它能够更好地管理内存并减少并发问题。

>请注意，单线程的CMS收集器会严重影响应用程序的吞吐量和响应性，因此应该尽量避免它的使用。


mysql for update（悲观锁） 如何实现的
-----
* 一、共享锁

  * SELECT语句 LOCK IN SHARE MODE;
  也叫读锁。针对同一条数据，多个事务读取操作可以同时加锁而互不影响 ，但是不能修改数据记录。
  * 例：
    * 事务1执行：SELECT * FROM student WHERE id=1 LOCK IN SHARE MODE;
    * 事务2也能顺利执行：SELECT * FROM student WHERE id=1 LOCK IN SHARE MODE;

但是注意：如果查询条件不采用带索引的列，则会提升为表锁。

例如：
* 事务1执行：SELECT * FROM student WHERE score=99 LOCK IN SHARE MODE;（score列无索引）
* 事务2不能再执行上述查询操作。
* UPDATE类的语句均不能同时执行。


* 二、排他锁
  * SELECT语句 FOR UPDATE;
  * 加锁的数据，不能被其他事务加锁查询或修改（普通查询不影响）。

大并发瞬时流量来的的时候 如何用concurrentHashMap接收
-----
如何解决的死锁
-----
jvm如何为对象分配内存的
-----
binlog的数据类型有哪些
-----
redolog uodolog的作用
-----

