### 一、如何体现你的产品思维
#### 目标
#### 结果

### 二、租车支付的核心点、难点
### 三、Mysql数据的结构，好处
### 四、MySql的数据的隔离级别，如何解决的幻读问题
### 五、Mysql的主从同步如何实现的，从节点获取主节点数据是推的模式，还是拉的模式
### 六、HashMap
### 七、ConcurrentHashMap实现原理，如何获取当前的容量
### 八、支付的稳定性建设
### 九、支付的强一致性
### 十、String、StringBuilder,StringBuffer区别
String、‌StringBuilder,StringBuffer在Java中各有其特定的用途和特点，‌主要区别体现在可变性、‌线程安全性、‌性能和适用场景上。‌

#### 可变性：‌
String：‌是不可变的，‌一旦创建，‌其值就不能被更改。‌对String对象的操作（‌如replace、‌subString、‌toLowerCase等）‌都会返回一个新的String对象，‌而不是修改原始对象。‌这导致每次操作String时性能较低，‌且浪费内存空间12。‌
StringBuilder：‌是可变的，‌提供了一个API与StringBuffer兼容，‌但没有线程安全的保证。‌它设计用于单个线程环境，‌作为StringBuffer的替代品，‌通常比StringBuffer更快34。‌
StringBuffer：‌也是可变的，‌但所有公开方法都是synchronized修饰的，‌确保线程安全。‌它适用于多线程操作同一个StringBuffer的场景3。‌
#### 线程安全性：‌
String：‌由于是不可变的，‌因此不需要考虑线程安全问题。‌
StringBuilder：‌不是线程安全的，‌适用于单线程环境34。‌
StringBuffer：‌是线程安全的，‌通过synchronized修饰的方法确保多线程环境下的安全性3。‌
#### 性能：‌
String：‌由于每次操作都会生成新的对象，‌因此在性能上可能不如其他两者高效12。‌
StringBuilder：‌在大多数实现中比StringBuffer快，‌因为它没有对方法加锁同步34。‌
StringBuffer：‌虽然提供了线程安全，‌但性能上可能不如StringBuilder，‌因为它需要对所有公开方法进行同步3。‌
#### 适用场景：‌
String：‌适用于不需要频繁修改的字符串操作，‌如常量字符串、‌网络传输等2。‌
StringBuilder：‌适用于单线程环境下需要频繁修改字符串的情况34。‌
StringBuffer：‌适用于多线程环境下需要共享和修改字符串的情况3。‌
综上所述，‌选择使用String、‌StringBuilder或StringBuffer应根据具体的应用场景和需求来决定，‌考虑到字符串的可变性、‌线程安全性以及性能等因素。‌
### 十一、Synchronized实现原理
### 十二、单侧覆盖率
### 十三、最近绩效、离职原因
### 十四、Thread和线程池的关系
#### 核心线程数，最大队列如何设计
##### 核心线程数和最大队列的设计应根据应用程序的具体需求和运行环境进行调整。‌

##### 核心线程数（‌corePoolSize）‌ 是线程池中始终存在的线程数量。
* ‌它的设置需要考虑预计的并发请求数、‌任务的类型（‌CPU密集型、‌IO密集型等）‌以及服务器的硬件资源情况。‌例如，‌对于高并发、‌响应速度要求高的Web应用程序，‌核心线程数可以设置为CPU核心数的两倍；‌而对于低并发、‌响应速度要求不高的批处理任务，‌核心线程数的设置则应根据任务的类型和预期的执行时间来决定。‌
##### 最大线程数（‌maximumPoolSize）‌ 表示线程池允许的最大线程数，‌即线程池的最大容量。
* ‌它的设置需要考虑服务器的硬件资源情况以及应用程序是否需要处理大量并发请求。‌在资源受限的环境中，‌最大线程数应设置得相对较小，‌以避免资源过度消耗；‌而在高并发系统中，‌可以适当增加最大线程数以提高系统的并发处理能力。‌
##### 任务队列 的设计应考虑队列的大小和类型（‌如ArrayBlockingQueue或LinkedBlockingQueue）‌，‌以及队列的饱和策略。
* ‌队列的大小应根据应用程序的负载和性能需求来设定。
* ‌对于需要高效处理大量任务的场景，‌可以选择使用LinkedBlockingQueue，‌因为它默认和最长长度可以达到Integer.MAX_VALUE，‌且吞吐量通常高于ArrayBlockingQueue。
* ‌当任务队列满时，‌应考虑采用合适的拒绝策略来处理无法立即执行的任务，‌以避免系统资源的浪费或任务的丢失。‌
>> 综上所述，‌核心线程数和最大线程数的设置应根据应用程序的具体需求和运行环境进行调整，‌同时考虑任务队列的大小和类型，‌以确保线程池的有效利用和系统的稳定运行。‌
### 十五、Thread Start和 run的区别
Thread的start()方法和run()方法的主要区别在于是否创建新的线程。‌

