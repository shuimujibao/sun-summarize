1、项目介绍
======
2、卡券的金额抵扣顺序
====
规则引擎是否适用

3、新增渠道是否发生数据结构的变化
====
4、数据强一致性系统做了哪些处理
====
5、在贝壳做了哪些工作
===
6、现在回头去设计原来的系统，你会怎么做
====
7、售卡项目的技术选型，是如何抉择的
===
8、财务对账的流程，目前遇到啥问题，系统层面是否可优化
======
8、mysql的锁机制 [解读](https://www.cnblogs.com/better-farther-world2099/articles/14955475.html)
====
## innodb行锁

### 1、隐式上锁（默认，自动加锁自动释放）
* select //不会上锁
* insert、update、delete //上写锁

### 2、显式上锁（手动）

* select * from tableName lock in share mode;//读锁
  * 第二个会话更新会被阻塞
* select * from tableName for update;//写锁


### 3、行锁的实现算法
#### (1) Record Lock 锁
>>单个行记录上的锁（点查）

Record Lock总是会去锁住索引记录，如果InnoDB存储引擎表建立的时候没有设置任何一个索引，这时InnoDB存储引擎会使用隐式的主键来进行锁定
#### (2) Gap Lock 锁（where范围数据）
>> 当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引加锁，对于键值在条件范围内但并不存在的记录。

优点：解决了事务并发的幻读问题

不足：因为query执行过程中通过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。

间隙锁有一个致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成锁定的时候无法插入锁定键值范围内任何数据。在某些场景下这可能会对性能造成很大的危害。

#### (3) Next-key Lock 锁
同时锁住数据+间隙锁

在Repeatable Read隔离级别下，Next-key Lock 算法是默认的行记录锁定算法。
#### 行锁的注意点
1. 只有通过索引条件检索数据时，InnoDB才会使用行级锁，否则会使用表级锁(索引失效，行锁变表锁)
2. 即使是访问不同行的记录，如果使用的是相同的索引键，会发生锁冲突
3. 如果数据表建有多个索引时，可以通过不同的索引锁定不同的行

## myisam表锁

9、redoLog、undoLog、binLog的产生节点以及作用 [解读](https://xiaolincoding.com/mysql/log/how_update.html)
=====
10、redis的rehash过程，以及发生的节点
======
11、zk的选举过程
===
12、paxios到zab简化了哪些地方
======
13、ddd领域设计的好处
====


